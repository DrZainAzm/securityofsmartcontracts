\subsection{Other Vulnerabilities relating Smart Contracts}
In the following some vulnerabilities of smart contracts on the Ethereum Platform and platforms interacting with them will presented, that did not fit in any of the categories mentioned before:

\subsubsection{Orphan Addresses}
There is no way to know, if a key that corresponds to a given address has been generated; so that addresses can not be validated. Addresses that do not correspond to a smart contract or a key are called \textit{orphan}, and Ether sent to this address is lost.\footnote{as mentioned at \cite[Page 11 (Ether lost in transfer)]{atzei:attacksurvey}}

The best-known orphan-address is \mintinline{solidity}{0x0} (that can be found at \cite{etherscan:addresszero}), where almost daily Ether is sent to by accident. Over time Ether worth over a million US-\$ has been sent to this address.

\subsubsection{Incentive Misalignment}
\label{section:other:incentive}
Another important objective content creators have to keep in mind is to set the incentives of the users right: It should never be an advantage to cheat or to leave out a transaction that would keep the contract going (as noted in \cite{delmolino:rps}).

An example where this could be problematic are commit-reveal-schemes, like proposed as a solution for the Rock-Paper-Scissors contracts presented in section \ref{section:vulnerability:miners:rockpaperscissor}. After the first player has revealed, the second player can see that move in the published transaction on the blockchain. If their own chosen hand would lose against the revealed move, there is no motivation to spend the gas to reveal and therefore to end the game. This would render the contract blocked and the winner unpaid.

A typical way to fix this problem is to demand a stake from the users: The improved version is presented in appendix \ref{appendix:rpsincentivescorrected}; when entering the game by committing in this implementation, an additional deposit has to be sent along. If the user reveals correctly, the deposit is refunded; if not, the deposit is kept as a fee for the owner after a timeout -- making it worth for the user to reveal a loosing hand.

\subsubsection{Address-length Attacks on Exchange-Websites}
The next vulnerability presented is not directly a vulnerability of smart contracts, but of platforms interacting with contracts: \texttt{poloniex.com} is an exchange platform where cryptocurrencies and tokens can be traded. To buy Tokens, a user can pay the platform and enter the Ethereum address the tokens are supposed to be sent to.

To transfer the tokens to the requested address, a transaction is created whose arguments are generated by concatenating the function selector of \mintinline{solidity}{transfer(address,uint)}, the padding bytes of the address, the address entered by the user, and the transferred value to call the function \mintinline{solidity}{transfer(address _to, uint256 _value)}.

This bug of the exchange-platforms was found by \cite{golemproject:addresslength}, who noticed that a way too short address had been entered: \texttt{0x79735} misses \( 140 \) bits to be complete address, which has a length of \( 20 \)-bytes. Because the following \( 32 \) bytes were just concatenated, the first  \( 140 \) bits of the following \mintinline{solidity}{uint}-value were consumed as the missing part of the address. This resulted in a following \mintinline{solidity}{msg.data}-string:
\begin{verbatim}
0xa9059cbb0
0000000000000000000000007973500000000000000000000000000000000000
00000000005150ac4c39a6f3f0000
\end{verbatim}

When accessing bits inside the EVM that were not provided by the \mintinline{solidity}{msg.data}, just \texttt{0}s are returned, so that the missing bytes are not noticed. This results in the contract receiving the amount to be transferred shifted by \( 140 \) bits to the left.

This could be abused by generating a address that ends on \texttt{00}s, which can be done using a simple script inside the geth-client console like
\begin{minted}{javascript}
var account; do { account = personal.newAccount(''); } while (!/00$/.test(account));
\end{minted}

Entering such an address without the \texttt{00} at the end in a vulnerable exchange would result a transferred amount to be left-shifted by \( 8 \) bit (which corresponds to a multiplication by \( 256 \)).
