\subsection{Solidity ABI}
\label{section:deepdive:abi}
The Ethereum Virtual Machine itself only provides a way to send arbitrary binary strings inside \mintinline{solidity}{msg.data} along with messages to smart contracts. In order for users or contracts to call specific functions, the Solidity \textit{Application Binary Interface} (short: ABI) provides standards for smart contract interaction:

The first four bytes of \mintinline{solidity}{msg.data} will be interpreted as the \textit{function selector}, which determines the function of the called contract that will be executed.

The function selector can be calculated from the function signature by using the first four bytes of the \texttt{keccak256}-hash of the function name along with its parameter types: For the function \mintinline{solidity}{allowWithdrawal} from the caution contract the function selector would be \texttt{33866f68}, which is the result of \mintinline{solidity}{bytes4(keccak256("allowWithdrawal(bool)"))}. The function to be used in the smart contract will then be determined at the beginning of the smart contract execution using conditional jumps:
\begin{verbatim}
PUSH 33866f68
EQ
PUSH [position of function start code]
JUMPI
\end{verbatim}

If no matching function selector is provided (for example in a simple message to send Ether), the code inside the \textit{fallback function} will be invoked, which in Solidity can be defined as a function without a name as in \mintinline{solidity}{function () public {}}.

After the function selector \mintinline{solidity}{msg.data} contains the function parameters in the same order as named in the function. The arguments are stored padded to occupy the default word length of the Ethereum virtual machine of 32 bytes; arguments with variable size like arrays (\mintinline{solidity}{uint[]}) or \mintinline{solidity}{string}s are stored at the end of the \mintinline{solidity}{msg.data}, starting with its size followed by all the elements in a row; at the original slot of the argument the starting position inside \mintinline{solidity}{msg.data} is referenced. Note, that if bytes of the call data that are outside the supplied \mintinline{solidity}{msg.data} are requested, just \texttt{0} is returned.

To describe the way a specific contract can be interacted with, the contract interface has to be described. As the contract interface is not included on the blockchain, it has to be provided externally.

For interactions using for example the JavaScript-console of the geth-Client or using user-friendly Wallet-applications, the JSON-ABI can be provided, that is being generated by the Solidity compiler as well. For \mintinline{solidity}{allowWithdrawal(bool)} the JSON-contract interface looks like this:\footnote{see \cite[Application Binary Interface Specification]{ethereum:solidity}}

\begin{minted}{json}
[
    {
        "constant": false,
        "inputs": [{
            "name": "_newDecision",
            "type": "bool"
        }],
        "name": "allowWithdrawal",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    },
]
\end{minted}

