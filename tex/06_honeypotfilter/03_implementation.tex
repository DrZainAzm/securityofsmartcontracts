\subsection{Implementation}
\textsc{Amphicyon} is implemented as a command line tool and npm library in typescript. The main reason for this choice was, that most Solidity source-code analysis tools like Solium are written in JavaScript, and therefore there already are simple ways to parse the Solidity code.

\subsubsection{Static Code Analysis}
The parser used to build the \textit{Abstract Syntax Tree} (AST) from the Solidity source code was generated by \texttt{PEG.js} (see \cite{github:pegjs}) using the Solidity Grammar also used in \texttt{solparse} (see \cite{github:solparse}). Classifiers are modules placed in the subfolder \texttt{./src/classifiers}, that provide some meta-information and the function \mintinline{solidity}{check()} executing the analysis:

\begin{minted}{typescript}
export interface Classifier {
  category: 'INTEREST' | 'UNDERHANDED SOLIDITY' | 'PATTERN' | 'FOLLOW-UP';
  using: 'SOURCECODE' | 'AST' | 'NAME' | 'ETHERSCAN';
  description: string;
  check: (contractInformation: ContractInformation) => {
    result: 'FOUND' | 'NOT FOUND' | 'NOT DECIDABLE';
    description?: string;
    occurrences?: AnalysisResultOccurrence[];
  };
}
\end{minted}

The check function receives information about the smart contract like its abstract syntax tree, its source code or metadata from the Etherscan website, and returns if the property could be found (or \mintinline{typescript}{'NOT DECIDABLE'} if the information required for this analysis was not provided) along with the position in the source code of the main node having this property. \textsc{Amphicyon} can be easily extended by programming another classifier and adding it as an export to \texttt{./src/classifiers/index.ts}

\subsubsection{Implemented Classifiers}
\textsc{Amphicyon} implements 18 different classifiers. Of those, 13 walk the AST to detect vulnerabilities, two work directly with the source code (which is used for example for detecting whitespaces that try to hide code), and three check the contract metadata from Etherscan (for example to detect the obvious 1 Ether contract balance). The classifiers have very different approaches:

The first subset containing four classifiers uses properties that were commonly found among honeypot contracts, but are not directly related to their traps: Those include a balance of almost exactly one Ether, an uppercase name, a size that can be easily understood (less than 150 lines of code) and an operation sending Ether to another account. Additionally, there are eight classifiers detecting the underhanded solidity coding techniques presented in section \ref{section:honeypot:underhanded}, like shadowed variables of the parent contract. Four additional classifiers were created to detect common coding patterns used in internal zero-value-call honeypots. The last classifier checks, if somebody sent Ether to the contract -- and was meant to be used to estimate the profit of smart contract honeypot creators. A table with all classifiers and a short description of their functionality can be found in appendix \ref{appendix:classifiers}.

The complexity of the classifiers varies from one-liners to tests spanning over multiple hundred lines of code:

For some properties, like when testing if a contract attempts to move code out of the visible area by using spaces, applying regular expressions was enough:
\begin{minted}{typescript}
matchAll(/([\s]{200,})[^\s].*$/m, contractInformation.sourceCode)
\end{minted}

Other classifiers walked the AST to detect common vulnerabilities: To find unsent call expressions like \mintinline{solidity}{msg.sender.call.value(1 ether)}, the walker looks for a node that is a member access like \mintinline{solidity}{.value()} or \mintinline{solidity}{.gas()}, and ensures, that this expression is not called again.

Especially the detection of coding patterns used in zero-value internal transactions-honeypots required more efforts: For those, some patterns used in this kind of honeypot are used: A popular trick is to introduce a variable, that can be changed by an external variable and that blocks the payment:

\begin{listing}[H]
	\begin{minted}[
        linenos=true,
        firstnumber=1
    ]{solidity}
contract InternalTransactionHoneypot {
    bool close = false;
    address owner = msg.sender;

    function retrieve() public payable {
        if(!closed && msg.value > 1 ether) {
            msg.sender.transfer(address(this).balance);
        }
    }

    function close(bool newStatus) {
        require(tx.origin == owner);
        close = newStatus;
    }
}
    \end{minted}
	\caption{A minimal honeypot, that can be locked using internal zero-value-transactions.}
	\label{lst:amphicyon:initializationPhase}
\end{listing}

To detect this vulnerability, the AST is walked and checked for the variables that fulfill the following three conditions:
\begin{itemize}
	\item state variable declared as \mintinline{solidity}{bool}
	\item variable that is being changed outside the constructor
	\item variable that appears during conditions that render the whole call without effect, like in line 5 or in \mintinline{solidity}{if(closed) throw;}.
\end{itemize}

\subsubsection{Filter and User Interface}
Since for most smart contracts multiple classifiers are evaluated to be true that for their own are not enough to flag a contract as as a honeypot, a more complex system was needed to decide from the result of the single classifiers whether a given contract is a honeypot or not. For this purpose, a bayes-filter was used, whose functionality is described in \cite{ct:spamfilter}.

Although \textsc{Amphicyon} is able to "learn" from manual decisions by calculating the bayesian probabilities from a set of manually classified smart contracts, due to the small amount of honeypots better results could be achieved by tweaking the conditional probabilities manually.

The tool contains a simple command line interface to analyze smart contracts: \textsc{Amphicyon} can analyze singe honeypots by their address or source code given in a file; but is also able to download and analyze multiple pages of the \textit{Verified Smart Contract}-page at once. The user can add manual decisions whether a contract is a honeypot or harmless, which are then used to improve the classifiers. A description of how to use \textsc{Amphicyon} can be found in the appendix \ref{appendix:amphicyon}.
